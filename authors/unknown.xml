<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PyPy (Posts by Unknown)</title><link>https://www.pypy.org/</link><description></description><atom:link href="https://www.pypy.org/authors/unknown.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:pypy-dev@pypy.org"&gt;The PyPy Team&lt;/a&gt; </copyright><lastBuildDate>Fri, 30 Aug 2024 08:28:16 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Async HTTP benchmarks on PyPy3</title><link>https://www.pypy.org/posts/2017/03/async-http-benchmarks-on-pypy3-1092124994927894138.html</link><dc:creator>Unknown</dc:creator><description>&lt;div class="" id="magicdomid3"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;Hello everyone,&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid4"&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid5"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;Since &lt;/span&gt;&lt;a href="https://blog.mozilla.org/blog/2016/08/04/mozilla-awards-585000-to-nine-open-source-projects-in-q2-2016/" target="_blank"&gt;Mozilla announced funding&lt;/a&gt;&lt;span class="author-g-1d7t1l2jbyeccm49"&gt;,&lt;/span&gt;&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt; we've been working quite hard on delivering you a working &lt;/span&gt;&lt;span class="author-g-1d7t1l2jbyeccm49"&gt;P&lt;/span&gt;&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;ython 3.5.&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid5"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt; &lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid5"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;We are almost ready to release an alpha version of PyPy 3.5. Our goal is to release it shortly after the sprint. Many modules have already been ported and  it can probably run many Python 3 programs already. We are happy to receive any feedback after the next release.  &lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid6"&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid7"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;To show that the heart (asyncio) of Python 3 is already working we have prepared some benchmarks. They are done by &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;Paweł Piotr Przeradowski @squeaky_pl&lt;/span&gt;&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt; for &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;a HTTP&lt;/span&gt;&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt; workload on serveral&lt;/span&gt;&lt;span class="author-g-1d7t1l2jbyeccm49"&gt;&lt;/span&gt;&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt; &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;asynchronous IO&lt;/span&gt;&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt; libraries&lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;, namely &lt;/span&gt;&lt;span class="author-g-1d7t1l2jbyeccm49"&gt;the &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;relatively new &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy i"&gt;&lt;i&gt;asyncio&lt;/i&gt;&lt;/span&gt;&lt;span class="author-g-1d7t1l2jbyeccm49 i"&gt;&lt;i&gt; and&lt;/i&gt;&lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt; &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy i"&gt;&lt;i&gt;curio&lt;/i&gt;&lt;/span&gt;&lt;span class="author-g-1d7t1l2jbyeccm49 i"&gt;&lt;i&gt; libraries&lt;/i&gt;&lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt; and&lt;/span&gt;&lt;span class="author-g-1d7t1l2jbyeccm49"&gt; the&lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt; battle-tested &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy i"&gt;&lt;i&gt;tornado&lt;/i&gt;&lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;, &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy i"&gt;&lt;i&gt;gevent and Twisted&lt;/i&gt;&lt;/span&gt;&lt;span class="author-g-1d7t1l2jbyeccm49 i"&gt;&lt;i&gt; libraries&lt;/i&gt;&lt;/span&gt;&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;. To see the benchmarks check out &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy url"&gt;&lt;a href="https://github.com/squeaky-pl/zenchmarks"&gt;https://github.com/squeaky-pl/zenchmarks&lt;/a&gt;&lt;/span&gt;&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt; and the instructions &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;for reproducing can be found inside README.md in the repository&lt;/span&gt;&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;. Raw results &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;can be obtained from &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy url"&gt;&lt;a href="https://github.com/squeaky-pl/zenchmarks/blob/master/results.csv"&gt;https://github.com/squeaky-pl/zenchmarks/blob/master/results.csv&lt;/a&gt;&lt;/span&gt;&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;.&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid8"&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid9"&gt;
&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;The
 purpose of the presented benchmarks is showing that the upcoming PyPy release 
is already working with unmodified code that runs on CPython 3.5. PyPy 
also manages to make them run significantly faster.&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid10"&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid11"&gt;
&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;The
 benchmarks consist of HTTP servers implemented on the top of the mentioned 
libraries. All the servers are single-threaded relying on underlying 
event loops to provide concurrency. Access logging was disabled to 
exclude terminal I/O from the results. The view code consists of a 
lookup in a dictionary mapping ASCII letters to verses from the famous 
Zen of Python. If a verse is found the view returns it, otherwise a 404 
Not Found response is served. The 400 Bad Request and 500 Internal 
Server Error cases are also handled.&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid12"&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid13"&gt;
&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;The workload was generated with the &lt;/span&gt;&lt;a href="https://github.com/wg/wrk" target="_blank"&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy i"&gt;&lt;i&gt;wrk&lt;/i&gt;&lt;/span&gt;&lt;/a&gt; H&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;TTP benchmarking tool. It is run with one thread opening up to 100 
concurrent connections for 2 seconds and repeated 1010 times to get 
consecutive measures. There is a &lt;a href="https://github.com/squeaky-pl/zenchmarks/blob/master/zenhttp.lua" target="_blank"&gt;Lua script &lt;/a&gt;provided&lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;
 that instructs &lt;a href="https://github.com/wg/wrk" target="_blank"&gt;wrk&lt;/a&gt; to continuously send 24 different requests that hit 
different execution paths (200, 404, 400) in the view code. Also it is 
worth noting that &lt;/span&gt;&lt;a href="https://github.com/wg/wrk" target="_blank"&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy i"&gt;&lt;i&gt;wrk&lt;/i&gt;&lt;/span&gt;&lt;/a&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt; will only count 200 responses as successful so the actual request per second throughput is higher.&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid14"&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid15"&gt;
&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;For your convenience all the used libraries versions are &lt;a href="https://github.com/squeaky-pl/zenchmarks/tree/master/vendor" target="_blank"&gt;vendored&lt;/a&gt; &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;into the benchmark repository. There is also a precompiled portable version of &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy i"&gt;&lt;i&gt;wrk &lt;/i&gt;&lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;provided
 that should run on any reasonably recent (10 year old or newer) Linux 
x86_64 distribution. The benchmark was performed on a public cloud &lt;/span&gt;&lt;a href="https://www.scaleway.com/" target="_blank"&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy i"&gt;&lt;i&gt;scaleway&lt;/i&gt;&lt;/span&gt;&lt;/a&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt; x86_64 server launched in a Paris data center. The server was running 
Ubuntu 16.04.01 LTS and reported Intel(R) Xeon(R) CPU D-1531 @ 2.20GHz 
CPU. CPython 3.5.2 (shipped by default in Ubuntu) was benchmarked 
against a &lt;a href="https://buildbot.pypy.org/nightly/py3.5/pypy-c-jit-90326-88ef793308eb-linux64.tar.bz2" target="_blank"&gt;pypy-c-jit-90326-88ef793308eb-linux64&lt;/a&gt;&lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt; snapshot of the 3.5 compatibility branch of PyPy.&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid16"&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid17"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;&lt;a href="https://1.bp.blogspot.com/-cjlKx06ZBaY/WLb_S3TBWuI/AAAAAAAAAmI/s2fsZ-SaJiwS2B-nAmyTheJfMQrKFHuQACK4B/s1600/graphs.png"&gt;&lt;img border="0" height="540" src="https://1.bp.blogspot.com/-cjlKx06ZBaY/WLb_S3TBWuI/AAAAAAAAAmI/s2fsZ-SaJiwS2B-nAmyTheJfMQrKFHuQACK4B/s640/graphs.png" width="640"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid19"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt; &lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid19"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt; &lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid19"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;&lt;a href="https://4.bp.blogspot.com/-Qn9iiR_-ZKA/WLb_pXFG9mI/AAAAAAAAAmQ/rvEYKM1KYbIzFmTeu9utt9oNALlc9mTNwCK4B/s1600/table.png"&gt;&lt;img border="0" height="306" src="https://4.bp.blogspot.com/-Qn9iiR_-ZKA/WLb_pXFG9mI/AAAAAAAAAmQ/rvEYKM1KYbIzFmTeu9utt9oNALlc9mTNwCK4B/s640/table.png" width="640"&gt;&lt;/a&gt; &lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid19"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt; &lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid19"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;We want to thank Mozilla for supporting our work!&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid19"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid19"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;Cheers,&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid19"&gt;
&lt;span class="author-g-1lpsz122z2ma8y7sqx7l"&gt;fijal, &lt;/span&gt;&lt;span class="author-g-d5i2rz122z7s6cn7iauy"&gt;squeaky_pl and the PyPy Team&lt;/span&gt;&lt;/div&gt;
&lt;div class="" id="magicdomid20"&gt;
&lt;br&gt;&lt;/div&gt;</description><guid>https://www.pypy.org/posts/2017/03/async-http-benchmarks-on-pypy3-1092124994927894138.html</guid><pubDate>Wed, 01 Mar 2017 17:28:00 GMT</pubDate></item><item><title>PyPy3 5.5.0 released</title><link>https://www.pypy.org/posts/2016/10/pypy3-550-released-8069558680221199646.html</link><dc:creator>Unknown</dc:creator><description>&lt;p&gt;We're pleased to announce the release of PyPy3 v5.5.0. Coming four months after PyPy3.3 v5.2, it improves compatibility with Python 3.3 (3.3.5). We strongly recommend updating from previous PyPy3 versions.&lt;br&gt;
&lt;br&gt;
We would like to thank all of the people who donated to the py3k proposal for supporting the work that went into this release.&lt;br&gt;
&lt;br&gt;
You can download the PyPy3.3 v5.5.0 release here: &lt;a href="https://pypy.org/download.html#python-3-3-5-compatible-pypy3-3-v5-5"&gt;https://pypy.org/download.html&lt;/a&gt;&lt;br&gt;
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Improved Python 3.3.5 support.&lt;/li&gt;
&lt;ul&gt;
&lt;li&gt;os.get_terminal_size(), time.monotonic(), str.casefold() &lt;/li&gt;
&lt;li&gt;faulthandler module&lt;/li&gt;
&lt;li&gt;There are still some missing features such as a PEP 393-like space efficient string representation and including performance regressions (e.g. issue #2305). The focus for this release has been updating to 3.3 compatibility. Windows is also not yet supported.&lt;/li&gt;
&lt;/ul&gt;
&lt;li&gt;&lt;i&gt;ensurepip&lt;/i&gt; is also included (it's only included in CPython 3 &amp;gt;= 3.4).&lt;/li&gt;
&lt;li&gt;Buffer interface improvements (numpy on top of cpyext)&lt;/li&gt;
&lt;li&gt;Several JIT improvements (force-virtual-state, residual calls)&lt;/li&gt;
&lt;li&gt;Search path for libpypy-c.so has changed (helps with cffi embedding on linux distributions)&lt;/li&gt;
&lt;li&gt;Improve the error message when the user forgot the "self" argument of a method&lt;/li&gt;
&lt;li&gt;Many more small improvements, please head over to our documentation for more information&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;
Towards Python 3.5&lt;/h3&gt;
&lt;div&gt;
&lt;div&gt;
We have started to work on Python 3.5, which is a version used by many software projects. It seems to get wide adoption. We are happy to be part of the Mozilla Open Source Support (MOSS) initiative.&lt;/div&gt;
&lt;div&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div&gt;
Nevertheless we want to give our users the chance to use PyPy in their Python 3 projects, thus we have prepared this release.&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;
What is PyPy?&lt;/h3&gt;
PyPy is a very compliant Python interpreter, almost a drop-in replacement for CPython 2.7.10 and 3.3.5. It's fast due to its integrated tracing JIT compiler.&lt;br&gt;
&lt;span style="white-space: pre-wrap;"&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;/span&gt; We also welcome developers of other dynamic languages to see what RPython can do for them.&lt;br&gt;
&lt;br&gt;
This release supports:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;x86 machines on most common operating systems except Windows &lt;/li&gt;
&lt;li&gt;newer ARM hardware (ARMv6 or ARMv7, with VFPv3) running Linux &lt;/li&gt;
&lt;li&gt;big- and little-endian variants of PPC64 running Linux &lt;/li&gt;
&lt;li&gt;s390x running Linux&lt;/li&gt;
&lt;/ul&gt;
Please try it out and let us know what you think. We welcome feedback, we know&lt;br&gt;
you are using PyPy, please tell us about it!&lt;br&gt;
&lt;br&gt;
Cheers&lt;br&gt;
&lt;br&gt;
The PyPy Team</description><category>release</category><guid>https://www.pypy.org/posts/2016/10/pypy3-550-released-8069558680221199646.html</guid><pubDate>Wed, 12 Oct 2016 09:37:00 GMT</pubDate></item><item><title>PyPy Tooling Upgrade: JitViewer and VMProf</title><link>https://www.pypy.org/posts/2016/08/pypy-tooling-upgrade-jitviewer-and-5107430577468391432.html</link><dc:creator>Unknown</dc:creator><description>&lt;p&gt;We are happy to announce a major JitViewer (JV) update.&lt;br&gt;
JV allows you to inspect RPython's internal compiler representation (the language in which PyPy is implemented) including the generated machine code of your program. It can graphically show you details of the JIT compiled code and helps you pinpoint issues in your program.&lt;br&gt;
&lt;br&gt;
VMProf is a statistical CPU profiler for python imposing very little overhead at runtime.&lt;br&gt;
&lt;br&gt;
Both VMProf and JitViewer share a common goal: Present useful information for your python program.&lt;br&gt;
The combination of both can reveal more information than either alone.&lt;br&gt;
That is the reason why they are now both packaged together.&lt;br&gt;
We also updated &lt;a href="https://vmprof.com/" target="_blank"&gt;vmprof.com&lt;/a&gt; with various bug fixes and changes including an all new interface to JV.&lt;br&gt;
&lt;br&gt;
This work was done with the goal of improving tooling and libraries around the Python/PyPy/RPython ecosystem.&lt;br&gt;
Some of the tools we have developed:&lt;br&gt;
&lt;br&gt;
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;b&gt;CFFI&lt;/b&gt; - Foreign Function Interface that avoids CPyExt (&lt;a href="https://cffi.readthedocs.io/en/latest/" target="_blank"&gt;CFFI docs&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;RevDB &lt;/b&gt;- A reverse debugger for python (&lt;a href="https://morepypy.blogspot.co.at/2016/07/reverse-debugging-for-python.html" target="_blank"&gt;RevDB blog post&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
and of course the tools we discuss here:&lt;br&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;VMProf&lt;/b&gt; - A statistical CPU profiler (&lt;a href="https://vmprof.readthedocs.io/en/latest/" target="_blank"&gt;VMProf docs&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;JitViewer&lt;/b&gt; - Visualization of the log file produced by RPython (&lt;a href="https://vmprof.readthedocs.io/en/latest/"&gt;JitLog docs&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3&gt;
A "brand new" JitViewer&lt;/h3&gt;
&lt;br&gt;
JitViewer has two pieces: you create a log file when running your program, and then use a graphic tool to view what happened.&lt;br&gt;
&lt;br&gt;
The old logging format was a hard-to-maintain, plain-text-logging facility. Frequent changes often broke internal tools.&lt;br&gt;
Additionally, the logging output of a long running program required a lot of disk space.&lt;br&gt;
&lt;br&gt;
Our new binary format encodes data densely, makes use of some compression (gzip), and tries to remove repetition where possible.&lt;br&gt;
It also supports versioning for future proofing and can be extended easily.&lt;br&gt;
&lt;br&gt;
And *drumroll* you no longer need to install a tool to view the log yourself&lt;br&gt;
anymore! The whole system moved to vmprof.com and you can use it any time.&lt;br&gt;
&lt;br&gt;
Sounds great. But what can you do with it? Here are two examples for a PyPy user:&lt;br&gt;
&lt;h3&gt;
&lt;br&gt;PyPy crashed? Did you discover a bug?&lt;/h3&gt;
&lt;br&gt;
For some hard to find bugs it is often necessary to look at the compiled code. The old&lt;br&gt;
procedure often required you to upload a plain text file which was hard to parse and to look through.&lt;br&gt;
&lt;br&gt;
A better way to share a crash report is to install the ``vmprof`` module from PyPi and execute either of the two commands:&lt;br&gt;
&lt;span&gt;&lt;br&gt;&lt;/span&gt;
&lt;span&gt;# this program does not crash, but has some weird behaviour&lt;/span&gt;&lt;br&gt;
&lt;span&gt;$ pypy -m jitlog --web &amp;lt;your program args&amp;gt;&lt;/span&gt;&lt;br&gt;
&lt;span&gt;...&lt;/span&gt;&lt;br&gt;
&lt;span&gt;PyPy Jitlog: https://vmprof.com/#/&amp;lt;hash&amp;gt;/traces&lt;/span&gt;&lt;br&gt;
&lt;span&gt;# this program segfaults&lt;/span&gt;&lt;br&gt;
&lt;span&gt;$ pypy -m jitlog -o /tmp/log &amp;lt;your program args&amp;gt;&lt;/span&gt;&lt;br&gt;
&lt;span&gt;...&lt;/span&gt;&lt;br&gt;
&lt;span&gt;&amp;lt;Segfault&amp;gt;&lt;/span&gt;&lt;br&gt;
&lt;span&gt;$ pypy -m jitlog --upload /tmp/log&lt;/span&gt;&lt;br&gt;
&lt;span&gt;PyPy Jitlog: https://vmprof.com/#/&amp;lt;hash&amp;gt;/traces&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Providing the link in the bug report allows PyPy developers to browse and identify potential issues.&lt;br&gt;
&lt;br&gt;
&lt;h3&gt;
Speed issues&lt;/h3&gt;
&lt;br&gt;
VMProf is a great tool to find hot spots that consume a lot of time in your program. As soon as you have identified code that runs slowly, you can switch to jitlog and maybe pinpoint certain aspects that do not behave as expected. You will find an overview, and are able to browse the generated code. If you cannot make sense of all that, you can just share the link with us and we can have a look too.&lt;br&gt;
&lt;h3&gt;
&lt;br&gt;Future direction&lt;/h3&gt;
&lt;br&gt;
We hope that the new release will help both PyPy developers and PyPy users resolve potential issues and easily point them out.&lt;br&gt;
&lt;br&gt;
Here are a few ideas what might come in the next few releases:&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt; Combination of CPU profiles and the JITLOG (sadly did not make it into the current release).&lt;/li&gt;
&lt;li&gt;Extend vmprof.com to be able to query vmprof/jitlog. &lt;br&gt;An example query for vmprof: 'methods.callsites() &amp;gt; 5' and&lt;br&gt;for the jitlog would be 'traces.contains('call_assembler').hasbridge('*my_func_name*')'.&lt;/li&gt;
&lt;li&gt;Extend the jitlog to capture the information of the optimization stage.&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
Richard Plangger (plan_rich) and the PyPy team&lt;br&gt;
&lt;div&gt;
&lt;br&gt;&lt;/div&gt;</description><guid>https://www.pypy.org/posts/2016/08/pypy-tooling-upgrade-jitviewer-and-5107430577468391432.html</guid><pubDate>Thu, 11 Aug 2016 11:52:00 GMT</pubDate></item></channel></rss>